import numpy as np
import argparse

def ORTH(B):
    """
    :param B: n × n
    :return:  rotates and reflects an arbitrary generator matrix into a square
    """
    A = np.dot(B, B.T)
    L = np.linalg.cholesky(A)

    'R=np.linalg.inv(L).T'
    'ret_B=np.dot(B,R)'
    return L


def gram_schmidt(B):
    """
    :param B: n × m
    :return: 正交基与系数
    """
    n, m = B.shape
    B_star = np.zeros_like(B, dtype=float)
    mu = np.zeros((n, n), dtype=float)
    for i in range(n):
        B_star[i] = B[i]
        for j in range(i):
            mu[i, j] = np.dot(B[i], B_star[j]) / np.dot(B_star[j], B_star[j])
            B_star[i] = B_star[i] - mu[i, j] * B_star[j]
    return B_star, mu


def RED(D, delta=0.75):
    """
    :param B: n × m
    :return: returns another generator matrix for the lattice generated by B
    in which the rows (basis vectors) are shorter and more orthogonal to each other than in B.
    """
    B = D
    n, m = B.shape
    B_star, mu = gram_schmidt(B)
    k = 1
    while k < m:
        # print(k)
        for i in range(k - 1, -1, -1):
            q = mu[k, i]
            if abs(q) > 0.5:
                B[k] = B[k] - round(q) * B[i]
                B_star, mu = gram_schmidt(B)
        if np.dot(B[k], B[k]) >= (delta - mu[k, k - 1] ** 2) * np.dot(B[k - 1], B[k - 1]):
            k = k + 1
        else:
            B[[k, k - 1]] = B[[k - 1, k]]
            B_star, mu = gram_schmidt(B)
            k = max(k - 1, 1)
    return B


def GRAN(n, m):
    """
    :param n:
    :param m:
    :return: returns an n × m
    matrix of random independent real numbers
    each with a Gaussian zero-mean, unit-variance distribution
    """
    while True:
        B = np.random.normal(0, 1, (n, m))
        if np.linalg.det(B) != 0:
            return B


def URAN(n):
    """
    :param n:
    :return: returns n random real numbers,
    which are uniformly distributed in [0, 1) and independent
    """
    return np.random.uniform(0, 1, n)


def sign(x):
    if x <= 0:
        return -1
    return 1


def CLPoint(B, x):
    """
    :param B:  lower-triangular generator matrices
    :param x:
    :return: not the closest point of x, (1,n)
    """
    # print("start:",B,x)
    B_inv = np.linalg.inv(B)
    u = np.dot(x, B_inv)
    # print("u:",u,u@B)
    u_rounded = np.round(u).astype(int)
    # print("u_rounded:",u_rounded)
    closest_point = B.dot(u_rounded)
    # print(closest_point)
    # d=np.linalg.norm(x-closest_point)
    # print(d)
    return u_rounded


def decode(H, x):
    """
    :param H:  lower-triangular generator matrices
    :param x:
    :return: the closest point of x, (1,n)
    """
    n = H.shape[0]  # Matrix dimension
    bestdist = np.inf
    k = n - 1  # Start at the top layer
    dist = np.zeros(n)
    e = np.zeros((n, n))
    u = np.zeros(n)
    step = np.zeros(n)
    u_hat = np.zeros(n)
    dist[k] = 0  # Distance to current layer
    e[k] = np.dot(x, H)  # Compute ek
    u[k] = np.round(e[k][k]).astype(int)
    y = (e[k][k] - u[k]) / H[k][k] 

    step[k] = sign(y)

    while True:
        newdist = dist[k] + y ** 2

        if newdist < bestdist:
            if k != 0:  # Case A: Move down to the previous layer
                for i in range(0, k):
                    e[k - 1][i] = e[k][i] - y * H[k][i]
                k -= 1  # Move down in the layer structure
                dist[k] = newdist
                u[k] = np.round(e[k][k]).astype(int)
                y = (e[k][k] - u[k]) / H[k][k]
                step[k] = sign(y)
            else:  # Case B: Found the best lattice point so far, update and move up
                u_hat = u.astype(int)
                bestdist = newdist  # Update
                k += 1  # Move up
                u[k] = u[k] + step[k]
                y = (e[k][k] - u[k]) / H[k][k]
                step[k] = -step[k] - sign(step[k])
        else:  # Case C: No improvement found, move up
            if k == n - 1:
                return u_hat
            else:
                k += 1
                u[k] = u[k] + step[k]
                y = (e[k][k] - u[k]) / H[k][k]
                step[k] = -step[k] - sign(step[k])


def CLP(B, x):
    return decode(np.linalg.inv(B), x)


def compute_NSM(B):
    n = B.shape[0]
    V = np.prod(np.diag(B))
    norm = []
    for _ in range(10000):
        z = np.random.uniform(0, 1, n)
        x = z @ B
        u = CLP(B, x)
        e = (z - u) @ B
        pro = np.linalg.norm(e) ** 2
        norm.append(pro)
    mean = np.mean(norm)
    return mean / (n * (V ** (2 / n)))


# the param can be changed
def iterative_lattice_construction(n, T=1000000, Tr=1000, u0=0.005, v=200):
    print("start to construct lattice for dimension:", n)
    B = ORTH(RED(GRAN(n, n)))
    print("the initial matrix:", B)
    V = np.prod(np.diag(B))
    B = (V ** (-1 / n)) * B
    for t in range(T):
        u = u0 * (v ** (-t / (T - 1)))
        z = URAN(n)
        y = z - CLP(B, z @ B)
        e = y @ B
        for i in range(n):
            for j in range(i):
                B[i, j] = B[i, j] - u * y[i] * e[j]
            B[i, i] = B[i, i] - u * (y[i] * e[i] - (np.dot(e, e) / (n * B[i, i])))

        '检查对角元素'

        if t % Tr == (Tr - 1) or t%T==(T-1):
            B = ORTH(RED(B))
            # nsm = compute_NSM(B)
            V = np.prod(np.diag(B))
            B = (V ** (-1 / n)) * B
            # print(f"iteration {t + 1}, NSM is: {nsm}")
    print("iteration finished.")
    return B


""" test example
B = np.eye(4)
B2 = np.random.normal(0, 1, (4, 4))
n = B.shape[0]
print(URAN(4))
print(GRAN(4, 4))
print(RED(B))
print(RED(B2))
print(ORTH(B))
print(ORTH(B2))
B = ORTH(B)
B2 = ORTH(B2)
u1 = CLP(B, np.array([0, 0, 0, 0]))
u2 = CLPoint(B2, np.array([0.5, 3, 2, 1]))
u3 = decode(np.linalg.inv(B2), np.array([0.5, 3, 2, 1]))
u4 = CLP(B2, np.array([0.5, 3, 2, 1])) # decode is always the best.
print(u1)
print(u2, np.linalg.norm(np.array([0.5, 3, 2, 1]) - u2 @ B2))
print(u3, u3 @ B2, np.linalg.norm(np.array([0.5, 3, 2, 1]) - u3 @ B2))
print(u4, np.linalg.norm(np.array([0.5, 3, 2, 1]) - u4 @ B2))
B_star = iterative_lattice_construction(3)
print(B_star)"""

if __name__=="__main__":
    parser=argparse.ArgumentParser()
    parser.add_argument("--n",type=int,default=10 ,help="Dimension")
    parser.add_argument("--T",type=int,default=1000000,help="Iteration times")
    parser.add_argument("--Tr",type=int,default=100,help="Interval")
    parser.add_argument("--u0",type=float,default=0.005,help="Initial step size")
    parser.add_argument("--v",type=int,default=200,help="Radio")
    args=parser.parse_args()

    np.random.seed(42)
    B=iterative_lattice_construction(args.n,args.T,args.Tr,args.u0,args.v)
    print("Final generate matrix B:",B)
    print("Final NSM:",compute_NSM(B))
